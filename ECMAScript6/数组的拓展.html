<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>11</div>
    <div>22</div>
    <div>33</div>
    <div>44</div>
    <div>55</div>
    <script>
        const {log} = console;
        function a(){
            log(...[1,2,3]);//1 2 3
            log(1,...[2,3,4],5);//1 2 3 4 5
            function f(a,b,c,d,e){
                return [a,b,c,d,e];
            }
            let args = [2,3];
            log(f(1,...args,...[4,5]));// [1, 2, 3, 4, 5]
            log(...[],1);//1
        };
        //a();

        //替代函数的apply方法
        function b(){
            //es5的写法
            function f(a,b,c){
                log([a,b,c]);
            };
            f.apply(null,[0,1,2]);// [0, 1, 2]
            f.apply(window,[0,1,2]);// [0, 1, 2]

            //es6写法
            f(...[1,2,3]);//[1, 2, 3]
        };
        //b();

        //push
        //push方法不能是数组
        function c(){
            //es5写法
            var arr1 = [0,1,2];
            var arr2 = [3,4,5];
            //Array.prototype.push.apply(arr1,arr2);
            //es6写法
            arr1.push(...arr2);
            arr1.push(6);
            arr1.push(7,8);
            arr1.push([1]);//这样直接添加了数组  [0, 1, 2, 3, 4, 5, 6, 7, 8, Array(1)]
            log(arr1);//[0, 1, 2, 3, 4, 5, 6, 7, 8]

        };
        //c();

        //Date
        function d(){
            //var dtae = new Date(String);
            log(new Date(...[2020,01,09]));
            log(Date.prototype);
            //getDate()	从 Date 对象返回一个月中的某一天 (1 ~ 31)。
            //getDay()	从 Date 对象返回一周中的某一天 (0 ~ 6)。
            //getFullYear()	从 Date 对象以四位数字返回年份。
            //getHours()	返回 Date 对象的小时 (0 ~ 23)。
            //getMilliseconds()	返回 Date 对象的毫秒(0 ~ 999)。
            //getMinutes()	返回 Date 对象的分钟 (0 ~ 59)。
            //getMonth()	从 Date 对象返回月份 (0 ~ 11)。
            //getSeconds()	返回 Date 对象的秒数 (0 ~ 59)。
             
        };
        //d();

        //复制数组
        //数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组
        function e(){
            const a1 = [1,2];
            const a2 = a1;//如果a2的值改变，那么a1的值也会被改变
            a2[0] = 2;
            log(a1);[2,2];

            //es5复制方法
            const a3 = [1,2];
            const a4 = a1.concat();
            a4[0] = 2;
            log(a3);//[1, 2]

            const a5 = [1,2];
            //const a6 = [...a5];
            const [...a6] = a5;
            a6[0] = 2;
            log(a5);//[1, 2]


        };
        //e();

        //合并数组
        function f(){
            const arr1 = [1,2];
            const arr2 = [3,4];
            //es5写法
            log(arr1.concat(arr2));//[1, 2, 3, 4]
            log([...arr1,...arr2]);//[1, 2, 3, 4]
            
        };
        //f();

        //与解构赋值结合
        function g(){
            const [first,...rest] = [1,2,3,4,5];
            log(first);//1
            log(rest);//[2, 3, 4, 5]
            const [first1,...rest1] = [];
            log(first1);//undefined
            log(rest1);//[]
            const [first2,...rest2] = ['foo'];
            log(first2);//foo
            log(rest2);//[]
        };
        //g();


        //拓展运算符还可以将字符串转为真正的数组
        function h(){
            log([...'hello']);//["h", "e", "l", "l", "o"]
        };
        //h();

        //实现了Iterator接口的对象
        function i(){
            let nodeList = document.querySelectorAll('div');
            log([...nodeList]);//[div, div, div, div, div]
            var divArr = [...nodeList];
            log(divArr[0].innerText);//11

            //这种类型虽然不是真正的数组，但是可以转成数组，不是说对象就可以通过Array.from转成数组
            let arrayLike = {
                0:'a',
                1:'b',
                2:'c',
                length:3
            };
            log(arrayLike);//{0: "a", 1: "b", 2: "c", length: 3}
            let arrayLike2 = Array.from(arrayLike);
            log(arrayLike2);//["a", "b", "c"]
            log(...[arrayLike2]);//["a", "b", "c"]


        };
        //i();

        //Map和Set解构，Generator函数
        function j(){
            let map = new Map([
                [1,'one'],
                [2,'tow'],
                [3,'three']
            ]);
            let arr = [...map.keys()];
            log(arr);//[1, 2, 3]
        };
        //j();

        //如果不是数组，将会报错
        function k(){
            const obj = {a:1,b:2};
            let arr = [...obj];//Cannot spreed non-iterable object
        };
        //k();

        //Array.from
        //实际运用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象，
        //Array.from都可以将它们转为真正的数组
        //如果是一个真正的数组，Array.from会返回一个一模一样的新数组
        //拓展运算符(...)也可以将某些数据结构转为数组

        //Array.from方法还支持类似数组的对象，所谓类似数组的对象，本质特征只有一点
        //即必须有length属性，因此，任何有length属性的对象，都可以通过Array.from方法转为数组
        //而此时拓展运算符就无法转换
        function l(){
            let div = document.querySelectorAll("div");
            var arr = Array.from(div).filter(p => {
                log(p.textContent);//11
                log(p.textContent.length);//2
                return p.textContent.length > 1;//[div, div, div, div, div]
            });
            log(arr);


            function foo(a,b,c){
                log(arguments);//Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
                log(Array.from(arguments));//[1, 2]
            };
            foo(1,2);

            log(Array.from({length:3}));//[undefined, undefined, undefined]
            //log([...{length:3}]);//Uncaught TypeError: log is not iterable (cannot read property Symbol(Symbol.iterator))
        };
        //l();

        //Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，
        //将处理后的值放入返回的数组
        function m(){
            let arrayLike = {
                0:'1',
                1:'2',
                2:'3',
                length:3
            };
            log(Array.from(arrayLike,x => x*x));//[1, 4, 9]
            log(Array.from(arrayLike).map(x => x*x));//[1, 4, 9]
            log(Array.from(document.querySelectorAll('div'),content => content.textContent));//["11", "22", "33", "44", "55"]
            log(Array.from([1,,3,,5],n => n||0));// [1, 0, 3, 0, 5]

            //这个例子是返回各种数据的类型
            function typesof(){
                return Array.from(arguments,value => typeof value);
            };
            log(typesof(null,[],NaN));//["object", "object", "number"]

        };
        //m();

        //Array.of()
        //Array.of方法用于将一组值，转换为数组
        function n(){
            log(Array.of(1,2,3));//[1, 2, 3]
            log(Array.of(1));//[1]
            log(Array.of(3).length);//1
            log(Array.of(undefined)); // [undefined]
            log(Array.of()); // []

            log([1,2,3].slice(1));//) [2, 3]
            //第二个参数代表取值的个数
            log([1,2,3].slice(0,2));//[1, 2]

            function ArrayOf(a,b){
                return [].slice.call(arguments);
            };
            log(ArrayOf(1,2));// [1, 2]
        };
        //n();

        //copyWithin()
        //在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），
        //然后返回当前数组，也就是说，使用这个方法，会修改当前数组
        //第一个参数，从该位置开始替换数据，如果为负数，表示倒数
        //第二个参数，从该位置开始读取数据，如果为负值，从末尾开始算,负数，从-1开始算
        //第三个参数，到该位置停止读取数据，默认等于数组长度，如果为负值，从末尾开始算
        function o(){
            log([1, 2, 3, 4, 5].copyWithin(0, 3));//// [4, 5, 3, 4, 5]
            // 对于没有部署 TypedArray 的 copyWithin 方法的平台
            // 需要采用下面的写法
            [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
            // Int32Array [4, 2, 3, 4, 5]
        };
        //o();

        //find(),findIndex()
        //弥补indexof的不足
        //用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有
        //数组成员依次执行该回调函数，知道找出第一个返回值为true的成员，然后返回该成员，
        //如果没有符合条件的成员，则返回undefined
        //可接受三个参数，依次为当前的值、当前位置和原数组
        function p(){
            log([1,2,-1,0].find(x => x < 0));//-1
            log([1,2,3,4].findIndex(function(value,index,arr){
                return value > 3;
            }));

            //这两个方法都可以接受第二个参数，用来绑定回调函数的this对象
            function f(v){
                return v > this.age;
            };
            let person = {name:'json',age:12};
            log([10,12,126,15].find(f,person));
        };
        //p();

        //fill()
        //fill方法使用给定值，填充一个数组
        //填充空数组非常方便，如果数组中已有的元素，会被全部抹去
        //fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置
        function q(){
            log(['a','b','c'].fill(7));//[7, 7, 7]
            log(new Array(3).fill(7));//[7, 7, 7]
            log(['a', 'b', 'c'].fill(7, 1, 2));//['a',7,'c']
            //如果填充的类似为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象
            let arr = new Array(3).fill({"name":"Mike"});
            arr[0].name = 'ben';
            log(arr);//[{name:'bne',name:'bne',name:'bne'}];
        }

        //entries(),keys(),values()
        //遍历数组，可以用for...of循环进行遍历，唯一的区别：
        //keys() 键名
        //values() 建值
        //entries() 建值对
        function r(){
            for (let index of ['a','b'].keys()){
                log(index);// 0 1
            };
            //可以理解为解构赋值
            for (let value of ['a','b'].values()){
                log(value);// a b
            };
            for (let [index,value] of ['a','b'].entries()){
                log(index,value);
            };
            //如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。
            let letter = ['a', 'b', 'c'];
            let entries = letter.entries();
            log(entries.next().value); // [0, 'a']
            log(entries.next().value); // [1, 'b']
            log(entries.next().value); // [2, 'c']
        };
        //r();




    </script>
</body>
</html>