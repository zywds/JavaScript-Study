<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const {log} = console;
        //ReExp构造函数的参数有两种情况
        //var regex = new Regex('xyz','i')
        //var regex = new Regex(/xyz/i)
        //var regex = /xyz/i

        //如果第二个参数指定修饰符，返回的正则表达式会忽略原有的修饰符，只使用新指定的修饰符
        //flags 返回修饰符
        log(new RegExp(/abc/ig,'i').flags); //i

        //String 是一个函数
        log(String.prototype);

        //macth()
        log(`abbc`.match(/b/)[0]); //b
        log(`abbc`.match(/b/g));//["b", "b"]
        for(let match of `abbc`.matchAll(/b/g)){
            log(match);//["b", index: 1, input: "abbc", groups: undefined]
        }

        //replace()
        log(`abbc`.replace(/b/g,'_'));//a__c

        //search()
        //返回存在的位置,只会返回找到的第一个，加了g也一样
        log(`abbc`.search(/b/g));//1


        //split()
        log(`abbc`.split());//["abbc"]
        log(`abbc`.split(''))//["a", "b", "b", "c"]
        log(`a_b_c_d`.split('_'));//["a", "b", "c", "d"]

        //正则匹配索引
        log(/ab/.exec(`zywdsabwab${`我是`}`));//"ab", index: 5, input: "zywdsabwab我是", groups: undefined]
        log(/ab/.exec(`zywdsabwab${`我是`}`)[0]);//ab
        log(/ab/.exec(`zywdsabwab${`我是`}`).index);//5
        log(typeof /ab/.exec(`zywdsabwab${`我是`}`));//object
        
        //具名组匹配
        const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;
        const matchObj = RE_DATE.exec('2021-12-12');
        log(matchObj);//["2021-12-12", "2021", "12", "12", index: 0, input: "2021-12-12", groups: undefined]
        log(matchObj[0],matchObj[1],matchObj[2],matchObj[3]);//2021-12-12 2021 12 12

        //分组
        //exec,match其实已经相对于分组了
        log(`2020-11-12`.match(/(\d{4})-(\d{2})-(\d{2})/));//["2020-11-12", "2020", "11", "12", index: 0, input: "2020-11-12", groups: undefined]



        //断言
        //先行断言
        //x只有在y前面才匹配
        //只匹配在某某之前的数据
        //g无效，
        //以%结尾
        log(/\d+(?=%)/.exec('11dd22%'));//["22", index: 4, input: "11dd22%", groups: undefined]
        //不以%结尾
        log('1111111');
        log(/\d{2}(?!%)/.exec("0011%aa22%33"));//["00", index: 0, input: "0011%aa22%33", groups: undefined]
        log(/\d{2}(?!%)/.exec("11%aa22%33"));//["33", index: 8, input: "11%aa22%33", groups: undefined]

        //后行断言
        //以%开头
        log(/(?<=\%)\d+/.exec(`11dd22%33ff`));//["33", index: 7, input: "11dd22%33ff", groups: undefined]
        //不以%开头
        log(/(?<!\%)\d+/.exec(`11dd%33g`));//["11", index: 0, input: "11dd%33g", groups: undefined]


        //RegExp.prototype.flags 
        //返回正则表达式的修饰符
        log(RegExp.prototype);
        log(/(?<=\%)\d+/igm.flags);//gim


        //RegExp.prototype.sticky
        //表示是否设置了y修饰符
        //记住，只针对于y修饰符
        log(/(?<!\%)\d+/y.sticky);//true

        //RegExp.prototype.unicode
        //表示是否设置了u修饰符
        log(/hello/.unicode);//false
        log(/hello/u.unicode);//true


        //y修饰符
        //y修饰符，也叫粘连(sticky)修饰符，y修饰符的作用与g修饰符类似，也就是全局匹配。后一次匹配都从
        //上一次匹配成功的下一个位置开始，不同之处在于，g修饰符只要剩余位置中存在匹配即可，而y修饰符确保匹配
        //必须从剩余第一个位置开始，着也就是粘连的涵义
        function a(){
            let s = 'aaa_aa_a';
            var r1 = /a+/g;
            var r2 = /a+/y;
            r1.exec(s);//["aaa"]
            r2.exec(s);//['aaa']
            r1.exec(s);//['aa'];
            r2.exec(s);//null
        }
        log(`a1a2a3`.match(/a\d/g));//["a1", "a2", "a3"]
        log(`a1a2a3`.match(/a\d/gy));//["a1", "a2", "a3"]

        //使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。
        log(/𠮷{2}/.test('𠮷𠮷'));//false
        log(/𠮷{2}/u.test('𠮷𠮷'));//true



    </script>
</body>
</html>