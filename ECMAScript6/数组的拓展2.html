<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const {log} = console;
        //includes()
        //Array.prorotype.include方法返回一个布尔值，表示某个数组是否包含给定的值，
        //与字符串的includes方法类似,存在返回true,indexof存在返回位置，否则返回-1
        function a(){
            log([1,2,3].includes(2));//true
            log([1,2,3].includes(4));//false
            log([1,2,NaN].includes(NaN));//true
            //该方法的第二个参数表示搜索的起始位置，默认为0，如果第二个参数为负数，则表示倒数位置，从-1开始
            //如果负数时它大于数组长度，则会重置为0,如果正数大于数组长度，则会报错
            log([1,2,3,1].includes(1,1));//true
            log([1,2,3,1].includes(1,-2));//tre
            log([1,2,3,1].includes(1,3));//true
            log([0,2,3,1].includes(1,-1));//true
            //log([1,2,3,1].includes(1,4));//false

            //NaN在indexof中会找不到返回-1，而在includes()中可以找到

        };
        //a();

        //array.some(function(currentValue,index,arr),thisValue)
        //会跳过空位
        //第一个参数：function(currentValue, index,arr)
        //第二个参数：可选：thisValue，对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"
        //返回布尔类型
        function b(){
            log([1,2,3].some(function(value,index,arr){
                return value === 2;//true
            }));
        };
        //b();

        //flat()
        //数组的成员有时还是数组，Array.prototype.flat()用于
        //将嵌套的数组拉平，变成一堆一维数组，该方法返回一个新数组，对原数据没有影响
        //flat默认只会拉平一层，第一个参数默认为1，如果要拉平多层，可加上参数
        //如果不管有多少层，都要转成一维数组，可以用infinity关键字作为参数
        //如果原数组为空，flat方法会跳过

        function c(){
            var arr = {
                name:'zywds',
                country:{
                    name2:'chinese',
                    s:[1,2,3]
                }
            };
            //解构赋值
            let {name,country:{name2,s}} = arr;
            log(name);
            log(name2);
            log(s);
            //flat
            log([1,2,[3,4]].flat());// [1, 2, 3, 4]
            log([1,2,[3,4,[5,6]]].flat(2));// [1, 2, 3, 4, 5, 6]
            log([1,2,[3,4]].flat(Infinity));// [1, 2, 3, 4]
            log([1,2,,4].flat());//[1, 2, 4]


        };
        //c();

        //flatMap()
        //对原数组的每个成员执行一个函数，相当于Array.prototype.map(),然后对返回值组成的数组
        //执行flat()方法，该方法返回一个新数组，不改变原数组
        function d(){
            log([1,2,3].flatMap(function(value){
                return [value,value*2];//[1, 2, 2, 4, 3, 6]
            }));
            //返回本来应该时双层数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组
            log([1,2,3].flatMap(value => [[value*2]]));//[[2],[4],[6]]

            //可以带第二个参数，用来绑定遍历函数里面的this
            let obj = {
                name:'zywds',
                age:2
            };
            function f1(value){
                return this.age > value;
            }
            log([1,2,3].flatMap(f1,obj));//[true, false, false]
            //箭头函数中this要注意，始终指向其本身对象
            //所有带第二个参数时，不要用箭头函数
            //log([1,2,3].flatMap((value) => {log(this);return this.age > value},obj));
        };
        //d();

        //数组的空位
        function e(){
            log(Array(3));
            log(Array(3).fill());//[undefined, undefined, undefined]
            log(0 in Array(3).fill());//true
            log(0 in Array(3));//false

        };
        //e();

        //forEach(),filter(),reduce(),every(),some()都会跳过空位
        //map()会跳过空位，但会保留这个值
        //join(),toString()会将空位视为undefined，而undefined和null会被处理成空字符串

        function f(){
            //forEach()
            [,'a'].forEach(function(value,index){
                log(value,index);//a 1
            });

            ['a',,'b'].filter(function(x){
                if (x){
                    log(x);//a b
                }
            });
            log(['a',,'b'].filter(x => true));//["a", "b"]
            //every
            //检测元素是否符合指定条件，返回布尔类型值，可以指定第二个参数为 this,作为回调时使用
            [,'a'].every(function(x){
                if (x === 'a'){
                    log(x);//a
                }
            });
            //累加器
            //reduce
            //可以指定初始值
            log([1,,3,5].reduce((x,y) => x+y,10));//19

            //some
            log([,'a'].some(function(x){
                return x === 'a';//true
            }));

            //map
            log([,'a'].map(x => x));//[, "a"]

            //join
            //将数组中的所有元素放入一个字符串，第一个参数为指定分隔符
            log([,'a',undefined,null].join('#'));//#a##

            //toString
            log([,'a',undefined,null].toString());//,a,,
        };
        //f();

        //方法比较类似的有：find,findIndex,every,some
        //filter:过滤的是你指定的条件，不是去掉，是留下来
        //reduce：累加器，可定义初始值
        //遍历的方法：map,forEach,for..of(for (let index of obj))

        //空位继续讲解：
        function g(){
            //Array.from方法会将数组的空位，转为undefined，不会忽略空位
            //将类似数组的转成数组，必须有iterator接口，要有length属性
            //也支持本身就是数组
            log(Array.from(['a',,'b']));// ["a", undefined, "b"]
            //拓展运算符(...)也会将空位转为undefined
            //得到的不是数组
            log(...['a',,'b']);//a undefined b
            //copyWithin()会连空位一起拷贝
            log(['a',,'b',,'c'].copyWithin(1,0,2));//["a", "a", , , "c"]
            //fill()填充  会将空位视为正常数组位置
            log(new Array(3).fill());// [undefined, undefined, undefined]
            log(new Array(3).fill(7));//[7, 7, 7]


            //entries(),keys(),values()会将空位处理成undefined
            //for...of
            //for...of循环也会遍历空位
            for (let value of [1,2,3,,4]){
                 log(value);
            }
            for (let index of [1,2,3,,5].keys()){
                 log(index);
            }
            log([1,2,,3].entries());//Array Iterator {}
            for (let [index,value] of [1,2,3,4,5,,6].entries()){
                log(index,value);//5 undefined
            }

            //find(),findIndex()会将空位处理成undefined
            log([,'a'].find(x => true));//undefined
            log([,'a'].findIndex(x => true),window);//0

            let obj = {
                age:12
            };
            //第二个参数可以加入对象，this指向对象
            log([11,12,13].findIndex(function(x){
                return x === this.age;
            },obj));//1



        };
        //g();

        //Array.prototype.sort()
        function h(){
            const arr = [
                {name:'zuwds1',age:10},
                {name:'zuwds1',age:8},
                {name:'zuwds1',age:6},
                {name:'zuwds1',age:11},
                {name:'zuwds1',age:18}
            ];
            let arr_1 = arr.sort((arr1,arr2) => {
                //arr1.age-arr2.age<0
                if (arr1.age < arr2.age) return -1;
                return 1;
            });
            log(arr_1);
            //{name: "zuwds1", age: 6}
            // {name: "zuwds1", age: 8}
            //{name: "zuwds1", age: 10}
            //{name: "zuwds1", age: 11}
            //{name: "zuwds1", age: 18}
        };
        h();






    </script>
</body>
</html>