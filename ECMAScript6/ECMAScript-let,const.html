<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
        let 声明的变量，只在let命令所在的代码块内有效




     -->
    <script>
        function a(){
            {
                let a = 10;
                var b = 1;
            }
            //console.log(a); //a is not defined
            console.log(b);
        }
        
        function b(){
            for (let i = 0;i<10;i ++){

            }
            console.log(i); //i is not defined
        }
        //b();

        function c(){
            //变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i
            //每一次循环，变量i的值都会发生改变，而循环内被赋值给数组a的函数内部的
            //console.log(i),里面的i指向的就是全局i,也就是说，所有数组a的成员里面的i
            //指向的都是同一个i,导致运行时输出的是最后一轮的i的值，也就是10

            var a =[];
            for (var i = 0;i<10;i++){
                a[i] = function(){
                    console.log(i);
                }
            }
            a[6]();
        }
        //c();
        function d(){
            //变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是
            //一个新的变量，所以最后输出的是6，你可能会问，如果每一轮循环的变量i都是
            //重新声明的，那它怎么知道上一轮循环的值，从而计算除本轮循环的值，这是
            //因为JavaScript引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮
            //循环的基础上进行计算
            var a =[];
            for (let i = 0;i < 10;i ++){
                a[i] = function(){
                    console.log(i);
                }
            }
            a[6](); //6
        }
        //d();
        
        function e(){
            //for 循环还有一个特别指出，就是设置循环变量的那部分是一个父作用域，而
            //循环体内部是一个单独的子作用域
            for (let i = 0;i< 10;i ++){
                let i = 'abc';
                console.log(i);
            }
        }
        //e();

        function f(){
            //不存在变量提升
            //var 命令会发生‘变量提升’现象，即变量可以在声明之前使用，值为undefined
            //这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用，否则报错
            //var 的情况
            console.log(foo);
            var foo = 2;//undefined
            //let 的情况
            console.log(bar);
            let bar = 2;//报错
        }

        function g(){
            //暂时性死区
            //只要块级作用域存在let命令，它所声明的变量就绑定 
            tmp = "abc";
            console.log(tmp); //ReferenceErrot
            let tmp;
            console.log(tmp);//undefined
            tmp = 123;
            console.log(tmp);//123

            //上面代码中，在let命令声明变量tmp之前，都属于变量tmp的‘死区’
            //‘暂时性死区也意味着typeof不再是一个百分百安全的操作’
            typeof x; //ReferenceError
            let x;

            //作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错
            typeof undeclared_variable; //undefined


        }

        //总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的
        //变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现
        //才可以获取和使用该变量
        function h(){
            //有些死区比较隐蔽，不太容易被发现
            //参数x默认值等于另一个参数y，而此时y还没有被声明，属于死区，如果y的默认值是x,就不会报错，
            //因为此时x已经声明了
            function bar(x=y,y=2){
                return [x,y];
            }
            bar();

            function bar1(x=2,y=x){
                return [x,y];

            }
            bar1();

            var x = x;//不报错
            let x = x;//报错，x的声明语句还没有执行完成前，就去取x的值，导致报错x未定义



        }

        //不允许在相同作用域内，重复声明同一个变量

        function i(){
            //报错
            function func(){
                let a = 10;
                var a = 1;
            }
            //报错
            function func1(){
                let a = 10;
                let a = 1;
            }

            //下面有个例子，不报错，不在相同作用域
            function func(){
                let arg;
            }
            func();//报错
            function func(arg){
                {
                    let arg;
                }
            }
            func();//正常
        }






    </script>
</body>
</html>