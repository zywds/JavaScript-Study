<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        function a(){
            let [a,b,c] = [1,2,3];
            console.log(a,b,c);
            let [foo,[[bar],baz]] = [1,[[2],3]];
            console.log(foo,bar,baz);
            let [x,,y] = [1,2,3];
            console.log(x,y);
            let [head,...tail] = [1,2,3,4,5];
            console.log(head,tail);
            let [x1,y1,...z1] = ['a'];
            console.log(x1,y1,z1);//a,undefined,[]
            //如果解构不成功，变量的值就等于undefined
            let [foo1] = [];
            console.log(foo1);//undefined
            let [bar2,foo2] = [1];
            console.log(foo2);//undefined

        }
        //a();

        function b(){
            let [x,y] = [1,2,3];
            console.log(x,y);//1,2
            let [a,[b],c] = [1,[2],3];
            console.log(a,b,c);//1.2.3
        }
        //b();

        //如果等号右边不是数组（或者严格地说，不是可遍历的解构，参见《interator将会报错）
        function c(){
            //前五个转为对象以后不具备iterator接口，
            let [foo] = 1;
            let [foo1] = false;
            let [foo2] = NaN;
            let [foo3] = undefined;
            let [foo4] = null;
            //本身就不具备iterator接口
            let [foo5] = {};
        }

        //set结构，也可以使用数组的解构赋值
        function d(){
            let [x,y,z] = new Set(['a','b','c']);
            console.log(x,y,z);//a,b,c
            //事实上，只要某种数据结构具有iterator接口，都可以采用数组新式的结构赋值


        }
        //d();

        //解构赋值允许指定默认值
        function e(){
            let [foo = true] = [];
            console.log(foo);//true
            let [x,y='b'] = ['a'];
            let [x1,y1='b']=['a',undefined];
            //ES6内部使用严格相等运算符（===），判断一个位置是否有值，
            //所以，只有当一个数组成员严格等于undefined，默认值才会生效
            let [x2 = 1] = [undefined];
            let [x3 = 1] = [null];
            console.log(x2);//1
            console.log(x3);//null

            function f1(){
                console.log('aaa');
            }
            let [x4=f1()] = [undefined];///a

        }
        //e();

        //默认值可以引用解构赋值的其它变量，但该变量必须已经声明
        //如果取不到值，最后等于undefined
        function f(){
            let [x = 1,y = x] = [];//1,1
            let [x1 =1,y1=x1] = [2];1,2
            let [x2 = y2,y2=1] = [1,2];
            console.log(x2,y2);//1,2
            //let [x3 = y3,y3 = 1] = [];//ReferenceError:y3 is not defined
            let [x4] = [];
            console.log(x4);//undefined
            
        }
        //f();

        //对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量
        function g(){
            //let {asin,log,sin,cos} = Math;
            //console.log(sin(1/2));
            
            //console.log(Math);
            //E,LN2,LN10,LOG2E,LOG10E,PI,SQRT1,SQRT2,abs,acos,
            //acosh,asin,asinh,atan,atan2,atanh,cbrt,ceil,cos
            //cosh,exp,expm1,floor,fround,hypot,imul,log,log2,log10
            //max,min,pow,random,round,sign,sin,sinh,sqrt,tan,tanh,
            //trunc
            //PI 圆周率
            //round 四舍五入
            //floor 取不大于x的最大整数
            //random 产生0-1随机数
            //sqrt 平方根

            const {log} = console;
            log("aaa");

            //与数组一样，解构也可以用于嵌套结构的对象
            let obj = {
                p:[
                    'hello',
                    {y:"world"}
                ]
            };
            let {p:[x,{y}]} = obj;
            console.log(x,y);//此时p不会被赋值
            //如果要p赋值
            let obj1 = {
                p1:[
                    'hello',
                    {y1:'world'}
                ]
            };
            let {p1,p1:[x1,{y1}]} = obj1;
            //x1 hello
            //y1 world
            //p1 ["hello",{y1:"world"}]




        }
        //g();
        //取不到值，就是undefined
        //只要某种数据结构具有interator接口，都可以采用数组新式的解构赋值
        function h(){
            //对象解构赋值
            
            let {name:name,age:age} = {name:"zywds",age:19};
            console.log(name)
            console.log(age);
        }
        //h();
        const {log} = console;
        function i(){
            log("12345");
        }
        //i();

        //变量与属性名一致，变量与属性名不一致
        //先找到同名属性，在赋值给变量,真正被赋值的是后者，而不是前者
        //foo是匹配的模式，baz才是变量，真正被赋值的是变量baz,而不是模式foo
        function j(){
            let {cos,sin,floor,random,round} = Math;
            let {foo:baz} = {foo:"12","bar":12}
            log(baz);
        }
        //j();

        //与数组一样，解构也可以用于嵌套解构的对象
        function k(){
            let obj = {
                p:[
                    'hello',
                    {y:"world"}
                ]
            };
            //此时p是模式，不是变量，因此不会被赋值，当然也可以写成被赋值
            //{p} 这样既是模式也是变量，因而也被赋值了
            let {p:[x,{y}]} = obj;
            console.log(x);
            console.log(y);
            //如果属性名和变量名一致，可以只写一边
            let {a} = {a:"123"};
            console.log(a);
        }
        //k();

        function l(){
            const node = {
                loc:{
                    start:{
                        line:1,
                        column:5
                    }
                }
            }
            let {loc:{start:{line,column}}} = node
            console.log(line);
            log(column);
            //log(start); //start is not defined

            //let {loc,loc:{start},loc:{start:{line}}} = node;
            //log(loc);//start:{line:1,column:5}
            //log(start);//line:1,column:5
            //log(line);//1
        }
        //l();

        function m(){
            let obj = {};
            let arr = [];
            ({foo:obj.prop,bar:arr[0]} = {foo:123,bar:true});
            log(obj);
            log(arr);
        }
        //m();

        //设置对象1的原型为对象2
        //只要具有iterator接口，就可以用数组方式解构赋值
        function n(){
            const obj1 = {}; 
            const obj2 = {name:"zywds"};
            //将obj1的原型对象设置为obj2
            Object.setPrototypeOf(obj1,obj2);
            let {name} = obj1;
            log(name);
        }
        //n();

        //对象的解构也可以指定默认值
        //默认值生效的条件是，对象的属性值严格等于undefined
        function o(){
            let {x = 3} = {}
            let {x1 = 3} = {x:undefined};
            let {x2 = 3} = {x:null};
            log(x); //3
            log(x1); //3
            log(x2); //3
        }
        //o();

        //如果要将一个已经声明的变量用于解构赋值，必须非常小心
        function p(){
            let x;
            //相当于重复定义变量了
            //{x} = {x:'111'};
            ({x} = {x:'111'});
            log(x);
        }
        //p();

        //解构赋值允许等号左边的模式之中，不放置任何变量名，因此，可以写出非常古怪的表达式
        function q(){
            //虽然毫无意义，但是语法是合法的，可以执行
            ({} = [1,2]);
            ({} = '123');
            ({} = []);
        }
        //q();

        //由于数组是特殊的对象，因此可以对数组进行对象属性的解构
        function r(){
            let arr = [1,2,3]
            let {0:first,[arr.length - 1]:length} = arr;
            log(first); //1
            log(length); //2
            //如果没有就是undefined
        }
        //r();


        //字符串的解构赋值
        function s(){
            console.log('123'.length);
            let [length] = 'abcdefg';
            log(length);
            let {length:length1} = 'abcdefg';
            log(length1); //7
        }
        //s();

        //解构的规则是，如果等号右边是数值和布尔值则会先转为对象
        //只要等号右边不是对象或数组，就先将其转为对象，由于undefined，和null
        //无法转为对象，所以对它们进行解构赋值，都会报错
        function t(){
            let s = 123;
            log(Number.prototype.toString === s.toString);
            //let {toString:a} = 123;
            //log(a);
        }
        //t();


        function u(){
            function add([x = 1,y = 1]){
                return x+y;

            }
            log(add([1]));
            //log(add());
            log(add([]));
            log(add([null,undefined]));
        }
        //u();
        //可以使用圆括号的情况，只有一种，赋值语句的非模式部分，可以使用
        function v(){
            [(b)] = [3];
            ({p:(d)} = {});
            [(parseInt.prop)] = [3];
        }


    </script>
</body>
</html>