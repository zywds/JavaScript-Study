<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const {log} = console;
        //Object.keys() 遍历所有属性的建名(不含继承)
        //Object.values() 遍历所有属性的建值(不含继承)
        //Object.entries()
        function c(){
            //先解构赋值，然后可以省略Object
            let {keys,values,entries} = Object;
            let obj3 = {one:1,two:2};
            //Object.keys()
            for (let key of keys(obj3)){
                log(key);
            };
            for (let value of values(obj3)){
                log(value);
            };
            for (let [key,value] of entries(obj3)){
                log(`${key}:${value}`);
            }
        };
        //c();

        function a(){
            let obj = {one:1,two:2};
            for (let [k,v] of Object.entries(obj)){
                log(k);
                log(typeof k);
                log(v);
                log(`${k}:${v}`);//one:1
            };

            //返回一个属性的键值对数组
            const obj1 = {one:1,two:2};
            log(Object.entries(obj1));//[["one":1], ["two":2]]

            //如果原对象的属性名是一个Symbol值，该属性会被忽略
            log(Object.entries({ [Symbol()]: 123, one: 1, two: 2}));//[["one":1], ["two":2]]
            log(Object.entries({ [Symbol()]: 123, foo: 'abc' }));

            //Object.entries方法的另一个用处是，将对象转为真正的Map结构
            const map1 = new Map(Object.entries({one:1,two:2}));
            log(map1);//Map(2) {"one" => 1, "two" => 2}
            const map2 = new Map([["one",1],["two",2]]);
            log(map2);//Map(2) {"one" => 1, "two" => 2}
        };
        //a();

        //Object.fromEntries()
        //是Object.entries()的逆操作,用于将一个键值对数组转为对象
        function b(){
            log(Object.fromEntries([['one',1],["two",2]]));//{one: 1, two: 2}
            const map3 = new Map().set('foo',true).set('bar',false);
            log(Object.fromEntries(map3));//{foo: true, bar: false}
        };
        //b();

        //Object.is()
        //比较两个值是否相等，es5中有两种,==,===（严格相等运算符）,前者会自动转换数据类型
        //否则严格比较，但是有个缺点，+0===-0:true,NaN===NaN:false
        function d(){
            log(Object.is('foo','foo'));//true
            //?????
            log(Object.is({},{}));//false
            log(Object.is(+0,-0));//false
            log(Object.is(NaN,NaN));//true

        };
        //d();

        //Object.assign()
        //用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象
        function e(){
            const obj1 = {a:1,b:2};
            const obj2 = {b:3,c:1};
            //后面的覆盖前面相同的
            log(Object.assign(obj1,obj2));//{a: 1, b: 3, c: 1}
            //如果只有一个参数，会直接返回该参数
            //如果该参数不是对象，会先转成对象
            log(Object.assign(true));//Boolean {true}
            //由于undefined，和null无法转成对象，所以如果它们作为参数，就会报错
            //不在首参数，不会报错，会跳过，不产生影响

        };
        //e();

        //__proto__属性
        //用来读取或设置当前对象的原型对象，目前，基本所有浏览器都部署了这个属性(包括IE11)
        function f(){
            //es5写法
            const obj1 = {one:1,two:2};
            const obj2 = {three:3};
            obj1.__proto__ = obj2;
            log(obj1.three);//3

            //es6写法
            //setPrototypeOf
            const obj3 = {one:1,two:2};
            const obj4 = {three:3};
            Object.setPrototypeOf(obj3,obj4);
            log(obj3.three);//3

            //如果第一个参数不是对象，会自动转为对象，但是由于返回的还是第一个参数，所以这个操作不会
            //产生任何效果
            log(Object.setPrototypeOf(1,{}));//1
            log(Object.setPrototypeOf(true,{}));//true
            log(Object.setPrototypeOf('foo',{}));//foo

            //由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错
            //log(Object.setPrototypeOf(undefined,{}));
            //log(Object.setPrototypeOf(null,{}));

        };
        f();







    </script>
</body>
</html>